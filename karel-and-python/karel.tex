\section{Introduction}

\subsection{Objectives} 

\begin{itemize}
\item Learn basic facts about the Karel language and its history. 
\item Learn how Karel differs from other programming languages.
\item Learn what this course will help you achieve.
\end{itemize}

\subsection{Brief history}

Karel the Robot is a famous educational programming language that was introduced by Richard E. 
Pattis in his book "Karel The Robot: A Gentle Introduction to the Art of Programming" in 1981. 
Pattis first used the language in his courses at Stanford University, and now it is used at 
countless schools in the world to introduce students to algorithmic design and computer programming. 
The language is named after Karel \v{C}apek, a Czech writer who invented the word "robot" in his 1921 
science fiction play R.U.R. (Rossum's Universal Robots).

\subsection{Who is Karel?}

Karel is a little robot that lives in a maze (Fig. \ref{fig:init45}), 
and there are gems in the maze that he loves to collect!
Sometimes multiple gems lie on each other, and in that case there is a number that shows their amount.
\begin{figure}[!ht]
\begin{center}
\includegraphics[width=40mm]{imgk/karel_logo.jpg}
\end{center}
\vspace{-2mm}
\caption{Karel}
\label{fig:init45}
%\vspace{-4mm}
\end{figure}

\noindent
The robot was manufactured with only five simple commands in his memory:
\begin{itemize}
\item {\color{green} \tt go} ... make one step forward.
\item {\color{green} \tt get} ... pick up a gem from the ground. 
\item {\color{green} \tt left} ... turn to the left.
\item {\color{green} \tt right} ... turn to the right. 
\item {\color{green} \tt put} ... put a gem on the ground. 
\end{itemize}
He also has five built-in sensors that allow him to check his immediate surroundings:
\begin{itemize}
\item {\color{green} \tt wall} ... true if he would crash into a wall by making one more step, false otherwise. 
\item {\color{green} \tt gem} ... true if he stands on a gem, false otherwise.
\item {\color{green} \tt north} ... true if he is facing North, false otherwise.
\item {\color{green} \tt home} ... true if he is at home, false otherwise.
\item {\color{green} \tt empty} ... true if his bag with gems is empty, false otherwise. 
\end{itemize}
During this course you will help Karel solve many exciting tasks starting with very simple ones and 
gradually progressing to more challenging. In this way Karel becomes a great robot, and you 
will become a great programmer!

\subsection{Why should I take this course?}

Computer programming skills are highly valued today, and they will be even more 
valued in the future. Karel's language is so natural that you will be able to 
focus on designing great algorithms. This is the most important skill in 
computer programming. In other words, you could start learning programming 
with a technically 
complicated conventional programming language as well, but you would spend lots of time 
battling technical problems. The advantage of starting with Karel is that 
when moving on to other languages, you will be able to focus on the technical 
differences, as the programming concepts you will already understand.


\subsection{Is Karel a toy language?}

Definitely not! Despite its playful appearance, Karel contains all elements 
of modern procedural programming. The complexity of algorithms 
that you will encounter in this course ranges from {\em extremely simple} 
to {\em extremely tough}. Towards the end of this course you will encounter 
tasks that will make your head spin. However, Karel is very light on 
technicalities, which is very good for someone who is just starting out.

The biggest conceptual difference between Karel and standard procedural
programming languages such as Python, C, C++ or Fortran is that {\em the robot does not 
know math}. At least not until we get to advanced levels that are beyond 
the original Pattis' book. In the basic course, you will solve many exercises 
whose objective is to teach you how to design great algorithms, and math is 
not needed for that. After finishing this tutorial, you will be able to transition 
smoothly to Python where you can do as much math as you like!
 
\section{Launching Karel}

\subsection{Objectives} 
\begin{itemize}
\item Learn to launch Karel and work with the graphical application.
\item Learn to clone displayed projects.
\item Learn that Karel has several modes.
\end{itemize}
Karel can be launched in several different ways. The simplest one is to click on the icon 
{\em Programming} and select {\em Karel} in the menu. This will launch the application 
with a randomly generated maze, as shown in Fig. \ref{fig:init}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=\textwidth]{imgk/init.png}
\end{center}
\vspace{-2mm}
\caption{Launching Karel with a random maze.}
\label{fig:init}
%\vspace{-4mm}
\end{figure}
\noindent
Karel will be launched in {\em Programming mode} which is the most-frequently 
used one. You can easily switch to the {\em Manual mode}, {\em Build mode},
and {\em Game mode} in the menu. These modes will be discussed in Paragraph 
\ref{levels}.

\subsection{Karel's window} \label{menu}

The application window contains two lines of menus and information on top,
work area on the left, maze on the right, and status bar on the bottom.
The menus are fairly intuitive, so let us just explain a few selected 
functions, starting with the {\em File} menu:

{\em Open} will open a file from your account (not from your hard disk). {\em New} will generate a new random maze.
{\em Clone} will copy a Displayed Project into your account (to be discussed in Paragraph \ref{cloning}). 
{\em Display} will submit your project for review. If you think that 
      other users would find your program or game interesting, this is the way to make it 
      available to them. Upon passing the review, your project will be added to Displayed Projects.

{\em Edit} menu allows you to operate with code and text cells (to be discussed in 
Section \ref{sec:editmenu}). In {\em Settings} you can change Karel's {\em Level} (to be discussed
in Paragraph \ref{levels}), change his speed, and adjust sound preferences. The green and red 
buttons are used to run and stop programs, respectively, and the two buttons next to them on
the right can be used to increase and decrease font size. The pair of icons on far right is the 
step counter (that can be reset by clicking on it) and gem counter that indicates how many gems 
Karel has in his bag.

\subsection{Cloning Displayed Projects} \label{cloning}

All programs and exercises that we will work with are available for you to clone. 
To do this, click on {\em Clone} in Karel's File menu. This will launch a new window 
with Displayed Projects as shown in Fig. \ref{fig:cloning}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=\textwidth]{imgk/cloning.png}
\end{center}
%\vspace{-2mm}
\caption{Many exercises and games are available through the File menu.}
\label{fig:cloning}
\end{figure}
\newpage
\noindent
All projects whose names start with "Karel - Exercise" are of particular interest 
for this tutorial. Their solutions have names starting with "Karel - Solution". 
Any of them can be cloned into your account via clicking on the project name in the window, 
and pressing the button {\em Clone}.

In the File Manager's right-hand side panel, you will see the list of all 
projects that you cloned. Click on any of them to launch it. You are free to 
use the cloned projects as they are, or modify them in any way you like. Your 
modifications will not affect the original. And, you can 
always synchronize your version with the original, via 
a right-click on the project in the File Manager and selecting {\em Synchronize}.
Keep in mind though -- synchronizing with the original will erase any changes that 
you made to the project.

\subsection{Karel modes} \label{levels}

Karel operates in four modes:
\begin{itemize}
\item {\em Manual mode:} The robot is controlled using the mouse and five buttons Go, Get, Left, Right, and Put. 
      Watch out and do not crash!
\item {\em Program mode:} The robot is controlled using written programs (computer code). The Program mode is 
      split into several Levels:
\begin{itemize}
\item Level 1 is a transition layer between the Manual and Programming modes. Programs are written using only 
      five commands {\tt go}, {\tt get}, {\tt left}, {\tt right}, and {\tt put} that exactly correspond to 
      the buttons Go, Get, Left, Right, and Put in Manual mode.
\item Level 2 is where the actual programming begins. On top of the commands from Level 1, programs can contain 
      conditions, loops, and custom commands.
\item In Level 3 Karel furthermore receives a GPS device. The user will learn to work with logical 
      and numerical variables. 
\end{itemize}
\item {\em Build mode:} This mode allows the user to create custom mazes.
\item {\em Game mode:} Makes it possible to create and play games. 
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Clicking} \label{sec:manual}

\subsection{Objectives} 
\begin{itemize}
\item Learn to operate the robot in Manual mode.
\end{itemize}
\noindent
Before we begin, let us review the four directions on the compass:\\[-7mm]

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=0.35\textwidth]{imgk/compass.png}
\vspace{-0mm}
%\caption{Karel's four possible orientations.}
%\label{fig:ori}
\end{center}
\vspace{-1cm}
\end{figure}

\noindent
When launching Karel through the Programming icon, switch to Manual mode using the corresponding 
menu button. Then, five buttons Left, Right, Go, Get and Put will appear in the panel on the left,
as shown in Fig. \ref{fig:buttons}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6.2cm]{imgk/buttons-all.png}
\vspace{-0mm}
\caption{Karel's buttons in manual mode (robot facing East).}
\vspace{-1cm}
\label{fig:buttons}
\end{center}
\end{figure}
\newpage
\noindent
The function of the buttons is self-explanatory -- pressing Left will turn the robot 90 degrees to the left,
pressing Right will turn him 90 degrees to the right, and pressing Go will move him one step forward 
(watch out and do not crash into a wall!). Upon pressing Put the robot will reach into his bag with gems, 
take one, and put it on the ground where he stands. Make sure that the bag is not empty before you do this!
An indicator showing how many gems are in the bag is in the upper right corner of the window. Last, upon pressing 
Get the robot will pick up a gem from the ground where he stands. Before you ask the robot to get a gem,
make sure that there is a gem on the ground though, or he will complain!

When the robot turns, the arrows on the buttons adjust automatically to his new 
orientation. This is illustrated in Fig. \ref{fig:buttons2}.
\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6.2cm]{imgk/buttons-all-2.png}
\vspace{-0mm}
\caption{Karel's buttons in manual mode (robot facing West).}
\label{fig:buttons2}
\end{center}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Programming} \label{sec:bridge}

\subsection{Objectives} 
 
\begin{itemize}
\item Start operating the robot in Programming mode.
\end{itemize}
In Programming mode, commands for the robot are entered into an code cell located in the left panel.
These commands are {\tt left}, {\tt right}, {\tt go}, {\tt get}, and {\tt put}.
Their function is the same as the function of the corresponding buttons in Manual mode.
One or more commands form a {\em computer program (computer code)}. Often 
we just say {\em program} or {\em code}.

There are two simple rules to remember:
\begin{enumerate}
\item Always type one command per line.
\item Do not enter empty characters in front of commands. 
\end{enumerate}
Ignoring these rules would not make your program invalid, but your code would be 
difficult to read. It is important to write a clean, transparent code that is easy to read. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Algorithms, Programs, and Bugs} \label{sec:interm1}

\subsection{Objectives} 
 
\begin{itemize}
\item Understand the difference between {\em algorithm} and {\em program}. 
\item Learn the difference between {\em syntactical} and {\em logical} mistakes.
\item Understand that {\em debugging} is an indivisible part of computer programming.
\end{itemize}
Karel always obeys all commands {\em precisely}. Sometimes it may happen that 
we plan one thing but to our surprise the robot does something else. In most cases this 
happens when our {\em algorithm} is wrong. By an {\em algorithm} we mean a sequence of 
logical steps that the robot needs to follow in order to fulfill his task. Algorithms 
are presented using normal human language, not in terms of the robot's commands. 

{\em Program} or {\em computer code} is created when the algorithm is expressed
in terms of the robot's language. When our algorithm is good, then 
the program is easy to write.

Mistakes in algorithms are called {\em logical errors}. A logical error is, for 
example, when we crash the robot into a wall because we forgot to make a turn.
Mistakes such as mis-spelling a command, writing "1o" instead of "10", or forgetting 
indentation are related to 
{\em syntax} and they are called {\em syntactical errors}. Of these two types, 
logical errors are usually much more difficult to find. 

In general, mistakes or either kind are called {\em bugs} and the procedure of 
eliminating them is called {\em debugging}. Depending on how careful we 
were while preparing our algorithm and writing the program, debugging takes either 
a short time or a long time. It does not happen often that a program works correctly
right away. 

When we commit a syntactical error,
the robot will write an error message and do nothing.
If our algorithm contains a logical error, then he will
write an error message and stop executing the program. 
The most usual logical error are:

\begin{itemize}
\item Karel crashes into a wall.
\item The robot tries to collect a gem where is none.
\item He attempts to put a gem on the ground while his bag is empty.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Counting Loop} \label{sec:repeat}

\subsection{Objectives} 

\begin{itemize}
\item Learn to make the robot repeat something a given number of times.
\end{itemize}

\noindent
In Section \ref{sec:bridge} we successfully crossed the bridge between manual control 
and programming. The bridge collapsed, there is no way back. But do 
not worry about that! The land of Programming is much more beautiful,
and once you understand its beauty, you will never want to leave.


\subsection{The {\tt repeat} command}

The {\em counting loop}, represented by the {\tt repeat} command, can save 
us lots of writing when something is repeated a given number of times. 
For example, for Karel to make 15 steps forward we could type:

\begin{verbatim}
go
go
go
go
go
go
go
go
go
go
go
go
go
go
go
\end{verbatim}
But this is neither efficient nor elegant. Instead, the same can be
achieved by telling Karel to {\tt repeat} the {\tt go} command {\tt 7} times:

\begin{verbatim}
repeat 15
    go
\end{verbatim}
There are a few simple rules that we need to remember when using the {\tt repeat} command:

\begin{itemize}
\item Keep code readable -- always write one command per line.
\item Indentation -- all commands to be repeated (the {\em body of the loop}) need to be indented. You can
      choose whether you prefer 2-indents or 4-indents. The former yields more compact 
      code with not-so-long lines, the latter is easier to read. 
\item Cancel the indentation for the first command that does not belong to the body of the loop.
\end{itemize}
To illustrate what the indentation does, let's look at a code that will move the robot 8 steps forward:

\begin{verbatim}
repeat 4
    go
    go
\end{verbatim}
Compare to a code that will only move the robot 5 steps forward:

\begin{verbatim}
repeat 4
    go
go
\end{verbatim}
Multiple {\tt repeat} commands can be {\em nested}. This means that a {\tt repeat} command 
can used in the body of another {\tt repeat} command. Everything that was said about indentation 
still holds. Can you figure out what the following code does?

\begin{verbatim}
repeat 10
    repeat 5
        go
    repeat 2
        left
\end{verbatim}
After you figure it out, launch Karel via the {\em Programming} menu, enter this code into
the code cell, and run it! But before you do, remember to switch to {\em Build mode} and make 
some free space in front of the robot 
so that he does not crash into a wall.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\iffullversion
\else
\vbox{}
\vfill
\pagestyle{empty}
    \begin{center}
    {\huge \color{red}END OF PREVIEW}\\[2cm]

\centerline{\Large Please consider:}
\vspace{1cm}

{\Large \bf Purchasing Online Course with Curriculum}
\vspace{1cm}

    {\Large or,}\\[1cm]

{\Large \bf Ordering Textbook and Solution Manual}
\vspace{1cm}

    {\Large For either, visit {\tt http://introtoprogramming.net}. \\[2cm]
}
\end{center}
{\bf The course includes}:
\begin{itemize}
\item Access to full version of textbook and solution manual.
\item One-click download of interactive review question worksheets.
\item One-click download of interactive programming exercises.
\item One-click distribution to students in your class.
\item One-click collection, automated grading, and progress monitoring.
\item Access to all answers and solution programs.
\end{itemize}

\vfill
    \end{document}
\fi



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Working with Code and Text Cells} \label{sec:editmenu}

\subsection{Objectives} 
 
\begin{itemize}
\item Learn how to add descriptive text cells.
\item Learn when it makes sense to have multiple code cells and how to add them.
\item Learn how to run all code cells at once, and how to run them individually.
\item Learn how to clear, collapse, remove and merge cells.
\end{itemize}
It is a very good habit to add comments to programs (every line starting with the '{\tt \#}'
symbol is a comment) and also to include descriptive 
texts in Karel worksheets, since descriptions make it easier for someone else to 
understand your program. Sometimes you may be in the position of the "someone else" yourself,
when you return to your own program some time after you wrote it. Here are a couple of 
simple new rules to remember:
\begin{enumerate} 
\item New text cell can be added above or under the current cell via the option 
      {\em Add new text cell} in the Edit menu. 
      After an empty text cell appears, click into it and add text. The text can be 
      formatted using Restructured Text Format (RST). After your text is finished, click 
      on {\em save} under the text cell. 
\item The most commonly used formatting operations in RST are 
      \begin{itemize}
      \item Making some text bold face. For this, put a double asterisk '{\tt **}' on either 
      side of the text. For example, type {\tt **This is bold face**} in RST.
      \item Headings are obtained by undelining some text with the '{\tt =}' symbols.
      An example of a heading is:
\begin{verbatim}
This is a Heading
=================
\end{verbatim}
      \item The RST format is very popular and so it is easy to Google more information
      if needed.
      \end{itemize}
\item New code cell can be added by clicking on {\em add} (located under each code cell). 
      Having multiple code cells can be useful, for example, to test various versions 
      of your program, or if you want to run parts of your program separately. 
\item Clicking on {\em clear} under an code cell will erase its contents.
\item Any cell can be collapsed by clicking on the bracket located on its right side. Collapsed
      cells can be expanded by clicking on the button that appears when a cell is 
      collapsed.
\item Clicking on {\em remove} under an code cell will remove it. All text in that cell will be lost.
\item Run programs via the green arrow button in the menu (this will evaluate all code
      cells). Each cell can be evaluated individually by clicking on {\em run} (located under 
      each code cell). If there is just one code cell, both options are equivalent.
\item Running programs can be stopped using the red button in the menu. 
\item If a particular
      code cell needs to be stopped, then use the {\em stop} button under that cell.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conditions} \label{sec:cond}

\subsection{Objectives} 

\begin{itemize}
\item Understand the function of Karel's five sensors.
\item Learn to use the sensors in conjunction with {\em conditions} to help Karel 
      check his surroundings and react accordingly. For example, you will learn to first 
      check whether wall is ahead before making a step forward, checking whether there
      is a gem on the ground before attempting to pick it up, etc.
\end{itemize}

\noindent
Karel has built-in sensors to better navigate in the maze:

\subsection{Karel's five sensors}

\noindent
\underline{{\tt wall} sensor}

The first one is an infrared sensor {\tt wall} that the robot uses to determine 
whether it is safe to make one step forward, or whether there is a wall. This is 
illustrated in Fig. \ref{fig:dede-ifelse}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[height=0.5\textwidth]{imgk/salih-ifelse.png}
\end{center}
\vspace{-4mm}
\caption{This is how Karel uses the {\tt wall} sensor!}
\label{fig:dede-ifelse}
%\vspace{-10mm}
\end{figure}
\noindent
The usage of the {\tt wall} sensor in a program can be illustrated using a simple program "Careful step" 
where Karel first checks whether there is a wall ahead before
making a step. If there is wall, he turns back: 

\begin{verbatim}
# Program "Careful step".
if wall
    repeat 2
        left
else
    go
\end{verbatim}
As we mentioned before, the symbol '{\tt \#}' introduces a comment, meaning that the line 
of code behind it is ignored by the robot.
The {\tt else} branch does not have to be there if it is not needed. Notice the indentation 
of the bodies of the {\tt if} and {\tt else} branches - this is analogous 
to how we indent the body of the {\tt repeat} command.\\

\noindent
\underline{{\tt gem} sensor}

This sensor returns true if the robot stands on a gem, false otherwise. \\

\noindent
\underline{{\tt empty} sensor}

This sensor returns true if the robot's bag with gems is empty, false otherwise. \\

\noindent
\underline{{\tt north} sensor}

This sensor returns true if the robot is facing North, false otherwise.\\

\noindent
\underline{{\tt home} sensor}

This sensor returns true if the robot is at home, false otherwise.\\

\noindent
\underline{Testing opposites}

Karel can also use the reserved word {\tt not} to test the opposites.
For illustration, the previous program can be rewritten as follows, without 
changing its function:
\begin{verbatim}
# Program "Careful step".
if not wall
    go
else
    repeat 2
        left
\end{verbatim}

\subsection{Programming hints}

Good programmer is a careful programmer! Errors can be avoided by always checking the 
appropriate sensor before making an action. A few examples of careful actions:
 
\begin{verbatim}
if not wall
    go
\end{verbatim}
Another example:
 
\begin{verbatim}
if gem
    get
\end{verbatim}
And a last one:
 
\begin{verbatim}
if not empty
    put
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conditional Loop} \label{sec:whilek}

\subsection{Objectives} 
 
\begin{itemize}
\item Learn to repeat a command or a sequence of commands when it is not known 
      how many repetitions will be needed.
\end{itemize}

\subsection{The {\tt while} command}

Often Karel needs to repeat something, {\em not knowing in advance how many repetitions
there will be}. So, the {\tt repeat} command is not practical. This can be the case, for example, 
when the robot is asked to walk straight ahead until he reaches the closest wall.
Remember that he only can see walls that are right ahead of him -- walls 
that are further away he can't see. Such a program would be:

\begin{verbatim}
while not wall
    go
\end{verbatim}
Or, Karel may be asked to walk until he gets home:

\begin{verbatim}
while not home
    go
\end{verbatim}
Beware though -- {\bf this program is dangerous} since the robot will crash into a wall
if his home is not straight ahead of him!

Another example: The robot may be asked to empty his bag (he does not know how many gems are in it): 
 
\begin{verbatim}
while not empty
    put
\end{verbatim}
Or, he may be asked to collect all gems from a pile (he does not know 
how many gems there are):

\begin{verbatim}
while gem
    get
\end{verbatim}
Or we may ask him to turn to face North (he does not know which direction he is
facing):

\begin{verbatim}
while not north
    left
\end{verbatim}
At last, let us face the following situation: Karel is asked to 
turn South, walk straight ahead until he reaches the closest wall, and 
collect all gems that he can find on the way:

\begin{verbatim}
# First turn North.
while not north
    left

# Then turn South.
repeat 2
    left

# Go straight ahead and pick all gems.
while not wall
    if gem
        get
    go

# Pick gem at the wall (if any).
if gem
    get
\end{verbatim}
Notice that we first need to turn the robot to face North -- this is because North 
is the only direction that he can check!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Custom Commands} \label{sec:newcom}

\subsection{Objectives} 
 
\begin{itemize}
\item Learn that replicating computer code is a very bad habit.
\item Learn that splitting the big task into smaller ones will simplify the solution a lot. 
\item Learn to bring more structure and clarity into your programs by introducing new commands.
\end{itemize}

\subsection{Programming hints}

{\em Always look for small tasks that can be solved independently of the big ones.
Solve the small tasks first, and you'll see that the big ones get much simpler. The 
importance of what we just said cannot be stressed more. Please read these three 
lines once more.}

\newpage
\noindent
The fact that you are reading this line of text proves that you are not 
a perfect programmer yet. Otherwise you would be stuck forever in the 
previous three lines that form an infinite loop!

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=0.3\textwidth]{imgk/smiley.png}
\end{center}
\vspace{-1cm}
\end{figure}

\subsection{Never replicate computer code!}

A new command should be defined whenever it becomes clear that the same 
action is repeated in the algorithm multiple times (yes, we talk about the algorithm,
not about the program). If you start writing a program and then realize that the same
code repeats itself at various places, then probably you did not do a good job 
designing the algorithm.

Sometimes it might be 
tempting to just replicate the same code several times in the 
program, because it does the same thing, but do not do it! This would be very bad programming
and sooner or later your own code would punish you for that. 
You would make a small change at one place but forget to do it 
in all the other places. Then your code would start 
acting strange, it would sometimes work and sometimes fail. 
You would spend lots of time looking for the mistakes, find some 
of them but not all, and your program would become unreliable
and after some time irreparable. You would find that you need to 
rewrite it from scratch.

\subsection{Defining new commands}

New commands are defined using the reserved word 
{\tt def}. For example, in a program where the robot needs to turn back
many times, it is a good idea to define a new command {\tt back}
as follows:

\begin{verbatim}
def back
    repeat 2
        left
\end{verbatim}
Note the indent -- the body of a new command needs to be indented 
analogously to the bodies of loops and conditions.

\subsection{Revisiting exercise A07}

Let us return to the exercise A07 - Right Button for a moment.
A really bad program to solve this task would be:

{\small
\begin{verbatim}
right
go
go
go
go 
get
right
go
go
go
go 
get
right
go
go
go
go
get
\end{verbatim}
}
\noindent
Can you see how many times the same code is repeated?! In order to fix this, 
we should define new command {\tt foursteps} as
follows:

{\small
\begin{verbatim}
def foursteps
    repeat 4
        go
\end{verbatim}
}
\noindent
With this new command, the above code simplifies to 

{\small
\begin{verbatim}
right
foursteps
get
right
foursteps
get
right
foursteps
get
\end{verbatim}
}
\noindent
There are still repetitions that must be eliminated! So we define a new command 
{\tt walkedge}:

{\small
\begin{verbatim}
def walkedge
    right
    foursteps
    get
\end{verbatim}
}
\noindent
Now with the new commands {\tt foursteps} and
{\tt walkedge}, our program simplifies to:

{\small
\begin{verbatim}
while not home
    walkedge
\end{verbatim}
}
\noindent
It is the task of the first exercise in this Section to implement this program. But before we 
do so, let us mention one very important thing.

\subsection{Solution procedure revisited}

Let's forget the commands that we defined above.
Experienced programmer would never approach the problem the way we did.
He (or she but let's use "he" for simplicity) 
would first look at the problem, trying to recognize repeating patterns. 
He would find that the task can be fulfilled by repeating one simpler task 
three times. So, without knowing exactly how the smaller task is going to 
be solved, he would write:

{\small
\begin{verbatim}
while not home
    walkedge
\end{verbatim}
}
\noindent
Next he would define the new command {\tt walkedge} as follows:

{\small
\begin{verbatim}
def walkedge
    right
    foursteps
    get
\end{verbatim}
}
\noindent
He would not bother defining the command 
{\tt foursteps} yet, because he knows that this will be 
simple. And as the last step, to make the program work, he would 
define:

{\small
\begin{verbatim}
def foursteps
    repeat 4
        go
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Recursion} \label{sec:recursion}

\subsection{Objectives} 
 
\begin{itemize}
\item Understand what recursion is and when it can be useful.
\item Learn to write good recursive algorithms.
\end{itemize}
By a {\em recursive} algorithm we mean an algorithm that uses itself. Doesn't it sound weird?
But in our life we use recursion all the time, for example when we descend a staircase.
With a bit of abstraction, our algorithm is:

\begin{verbatim}
Descend_staircase
    Descend one step
    If this was not the last step
        Descend_staircase
\end{verbatim}
Recursion is not advantageous for all types of problems, but it can be really 
helpful, especially for problems where 
\begin{itemize}
\item we can do some work to reduce the problem to the same one but smaller in size, 
\item we can apply the same algorithm to the smaller problem. 
\end{itemize}
On program level, this means that some command calls itself, either 
directly or through other commands.

\subsection{How it works} 

Consider the following program:
\begin{verbatim}
def reach_wall
    if not wall
        go
        reach_wall

reach_wall
\end{verbatim}
Imagine that the initial position of the robot is like in Fig. \ref{fig:rec1}.


\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6cm]{imgk/rec-1.png}
\end{center}
\vspace{-4mm}
\caption{Robot's initial position.}
\label{fig:rec1}
\vspace{-4mm}
\end{figure}
\noindent
When the command {\tt reach\_wall} is first called, the robot stands three steps away from the wall and 
thus the {\tt if not wall} condition passes. Then the command {\tt go} follows and the robot's 
position changes as shown in Fig. \ref{fig:rec2}. 

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6cm]{imgk/rec-2.png}
\end{center}
\vspace{-4mm}
\caption{Robot's position after the first {\tt if not wall} condition passes and he makes the first step forward.}
\label{fig:rec2}
\vspace{-4mm}
\end{figure}
\noindent
Next the robot executes the {\tt reach\_wall} command that follows the {\tt go} command. A good way to 
understand what happens is to imagine that the command is replaced with its own body. The corresponding 
program would look as follows:

\begin{verbatim}
if not wall
    go
    if not wall
        go
        reach_wall
\end{verbatim}
\noindent
Since the robot is two steps away from the wall, the second {\tt if not wall} condition passes and 
he makes a second step forward. His new position is shown in Fig. \ref{fig:rec3}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6cm]{imgk/rec-3.png}
\end{center}
\vspace{-4mm}
\caption{Robot's position after the second {\tt if not wall} condition passes and he makes a second step forward.}
\label{fig:rec3}
\vspace{-4mm}
\end{figure}
\noindent
Next the robot executes the third {\tt reach\_wall} command. Again we can imagine that the command 
is replaced with its own body. The corresponding program would look as follows:

\begin{verbatim}
if not wall
    go
    if not wall
        go
        if not wall
            go
            reach_wall
\end{verbatim}
\noindent
Since the robot is one step away from the wall, the third {\tt if not wall} condition passes and 
he makes a third step forward. His new position is shown in Fig. \ref{fig:rec4}.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=6cm]{imgk/rec-4.png}
\end{center}
\vspace{-4mm}
\caption{Robot's position after the third {\tt if not wall} condition passes and he makes a third step forward.}
\label{fig:rec4}
%\vspace{-10mm}
\end{figure}
\noindent
Next the robot executes the {\tt reach\_wall} command again and we can imagine that the command 
is replaced with its own body. The corresponding program would look as follows:

\begin{verbatim}
if not wall
    go
    if not wall
        go
        if not wall
            go
            if not wall
                go
                reach_wall
\end{verbatim}
\noindent
However, now the robot is facing the wall and thus the {\tt if not wall} condition does not pass.  
This means that the program is finished!

\subsection{The base case}

In the previous example we have seen one important fact: To prevent infinite recursion, one always needs {\tt if} or {\tt if-else} 
statement of some sort where one branch makes a recursive call, and the other branch is either 
missing or it does not make a recursive call. The branch without a recursive 
call is called the {\em base case}. A bad example of a recursive command without a base case would be 

\begin{verbatim}
def left_forever
    left
    left_forever
\end{verbatim}
\noindent
You can guess where the name of this command comes from! Fortunately, the program can be stopped using 
either the red button or the {\tt stop} button under the code cell.

\subsection{When should recursion be used?}

The recursive command {\tt reach\_wall} that we defined above may not be the most useful example 
since the same functionality could be achieved more elegantly without recursion, just with

\begin{verbatim}
def reach_wall
    while not wall
        go
\end{verbatim}
If there is a small task that needs to be solved repeatedly in order to get a bigger task done,
then often one can write both a non-recursive and a recursive algorithm. Recall for example the Diamond
Staircase example from Section \ref{sec:newcom}. The small task there was to climb one step and pick 
up the gem, ending up facing east. The non-recursive version of the algorithm would be:

\begin{verbatim}
def climb_one_step
    left
    go
    right
    go
    get

while not home
    climb_one_step
\end{verbatim}
The recursive version of the algorithm looks as follows:

\begin{verbatim}
def climb_the_stairs
    if not home
        left
        go
        right
        go
        get
        climb_the_stairs

climb_the_stairs
\end{verbatim}
If it is easy to write a non-recursive version of an algorithm, then it should be used
because in general, non-recursive algorithms are faster. 
Recursive version of an algorithm should be used if a non-recursive version would 
be difficult to design. For example, nearly all code written for tree-like structures 
is recursive. Also many sorting algorithms are more naturally written in recursive form.
We will come to these subjects later.

\subsection{Mutually recursive commands}

Recursion can have interesting forms. In its simplest shape, a command 
calls itself in its own body. But, we can have a pair of commands
that call themselves mutually, such as the commands {\tt odd} and 
{\tt even} in the following example (that also solves the Diamond Staircase
problem by the way):
 
\begin{verbatim}
def climb_step
    left
    go
    right
    go
    get 

def odd
    if not home
        climb_step
        even
    
def even
    if not home
        climb_step
        odd
    
odd
\end{verbatim}
Obviously this program is not the most efficient one to solve the 
Diamond Staircase problem, but it is great for illustration purposes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Variables} \label{sec:var}

Now we are entering exciting Level 3! Karel grew up and left the home of his 
parents to go through life on his own. Therefore, his home will not be present
in the following exercises and games anymore. There are a few more changes
that reflect Karel's growing up, including numerical and logical variables,
and functions. Therefore, do not forget to adjust the 
Level in Settings accordingly. A compact overview of new functionality in Level 3
can be found in Section \ref{sec:newfunc3}.

\subsection{Objectives} 
 
\begin{itemize}
\item Understand the concept of variables.
\item Learn to work with numerical and logical variables.
\item Learn to use functions that return values. 
\end{itemize}

\noindent
In programming, variables are used to store useful information for later use. This information can 
be a number, word, sentence, or anything else. 

\subsection{Various types of variables}

All of us are using variables in our lives. One of 
the first ones is our own name. With a bit of abstraction (and say that your name is "Melissa"), 
when you were about two years old, you did the following:

\begin{verbatim}
my_name = "Melissa"
\end{verbatim}
Since then, each time someone called a name, you retrieved in your brain the value of the variable
{\tt my\_name}, compared it to the name that you heard, and if you got a match then you turned around 
to see who was calling you. Imagine that we would not be able to use that variable!

The variable {\tt my\_name} stores a word (string of characters). We also use many numerical variables such as
{\tt seconds\_per\_minute} whose value is 60, {\tt minutes\_per\_hour} whose value is 60 as well, 
{\tt hours\_per\_day} whose value is 24, and we could go on. The last three variables do not change 
too often, most likely they will not change during our lives. But we also use variables whose 
values change, such as {\tt days\_per\_year}, {\tt number\_of\_my\_pets}, etc.

Next let's look at logical variables. Those are variables that only can store two possible values --
{\tt True} or {\tt False}, and we use a huge number of them. One such example may be {\tt I\_speak\_a\_foreign\_language}.
For someone this variable has the value {\tt False}, for someone it is {\tt True}. The important 
thing is that when someone asks you about that, you do not need to go check the records in the language 
school -- you just know it. The value is {\em stored}, it does not have to be {\em created} each time 
it is needed. Logical variables will be discussed in more detail shortly, now let us explore 
the numerical ones.

\subsection{Reading GPS coordinates}

Karel's coolest Christmas present was a new GPS device that allows him to determine his position 
in the maze. With it, he will never get lost again! He can retrieve his coordinates at any time via the 
kaywords {\tt gpsx} and {\tt gpsy}. He also has a new ability to output results via the {\tt print} 
command. The usage of these commands is best illustrated using the following short program where 
Karel determines his coordinates in the maze and prints them:

\begin{verbatim}
print "Horizontal position:", gpsx
print "Vertical position:", gpsy
\end{verbatim}
The south-west corner of the maze is the origin of the coordinate system and it has 
coordinates [0, 0]. In other words, if the above program is executed while Karel stands 
in the south-west corner, the output is

\begin{verbatim}
Horizontal position: 0
Vertical position: 0
\end{verbatim}
The maze's width (in west-east direction) is 15 tiles, and its height (in south-north direction) 
is 12 tiles. Therefore, while Karel stands in the north-east corner, the output of the program is
\begin{verbatim}
Horizontal position: 14
Vertical position: 11
\end{verbatim}
Try it! Also move Karel to other parts of the maze in Build mode and run the program again
to make yourself familiar with how the GPS device works.

\subsection{Custom Functions}

In Level 3 we can use the reserved word {\tt return} inside the body of
a command to return a value. Such commands are then called {\em functions}. 
They are also defined using the keyword {\tt def}. For example, the following function
{\tt count\_steps} will return the number of steps the robot needed to 
make in order to reach the closest wall in the direction that he was facing:

\begin{verbatim}
def count_steps
    n = 0
    while not wall
        go
        inc(n)
    return n
\end{verbatim}
The function can be then used as follows:

\begin{verbatim}
num = count_steps
print "Number of steps:", num 
\end{verbatim}

\subsection{Creating numerical variables} \label{par:var}

In Karel, numerical variables can be created in several different ways: 
\begin{enumerate}
\item By setting them to an integer number. For example, new variable {\tt a} is created and set to zero by typing 
\begin{verbatim}
a = 0
\end{verbatim}
\item By setting them to {\tt gpsx}. For example, new variable {\tt var} is created and set to {\tt gpsx} by typing
\begin{verbatim}
var = gpsx
\end{verbatim}
\item By setting them to {\tt gpsy}. For example, new variable {\tt pos1} is created and set to {\tt gpsy} by typing
\begin{verbatim}
pos1 = gpsy
\end{verbatim}
\item Initialize them with an existing value. For example, if we already have a variable {\tt var1}, then a new variable 
{\tt var2} can be created as follows:
\begin{verbatim}
var2 = var1
\end{verbatim}
\item Initialize them with value returned by an existing function, as it was shown in the previous 
paragraph. 
\end{enumerate}

\subsection{Changing values of numerical variables}

The value of a numerical variable can be updated at any time by redefining it via 
one of the four options described in the previous paragraph. For example, let's say that 
Karel stands as shown in Fig. \ref{fig:var1}.
\begin{figure}[!ht]
\begin{center}
\includegraphics[height=0.4\textwidth]{imgk/variables1.png}
\end{center}
\vspace{-4mm}
\caption{Karel's initial position.}
\label{fig:var1}
%\vspace{-1cm}
\end{figure}
\noindent
The program

\begin{verbatim}
a = gpsx
print "Start position:", a
repeat 5
    go
a = gpsx 
print "End position:", a
\end{verbatim}
will produce the following output:

\begin{verbatim}
Start position: 5
End position: 10
\end{verbatim}
Another way to change the value of a numerical variable is to increase it by one or 
decrease it by one via the commands {\tt inc()} and 
{\tt dec()}, respectively. Commands {\tt inc(a, num)} and 
{\tt dec(a, num)} will increase / decrease the value of variable {\tt a}
by an integer number {\tt num}.

Consider again Karel's initial position as shown 
in Fig. \ref{fig:var1}. Then the code

\begin{verbatim}
a = zero
while not wall
    go
    inc(a)
print "Went", a, "steps before reaching a wall."
\end{verbatim}
will have the following output:

\begin{verbatim}
Went 7 steps before reaching a wall.
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Logic} \label{sec:logic}

\subsection{Objectives} 
 
\begin{itemize}
\item Learn to work with elementary and more complex logical expressions.
\end{itemize}

\subsection{Logical expressions}
As we already know, logical expressions are expressions that can be answered with either {\tt True} or 
{\tt False}. We say that the {\tt True} or the {\tt False} is their value. Here are some 
real-life examples, try to answer them with {\tt True} or {\tt False}:

\begin{itemize}
\item "I am 15 years old."
\item "My dad is a teacher."
\item "My school's name is Coral Academy."
\end{itemize}
And here are some Karel examples:
\begin{itemize}
\item wall ({\tt True} if the robot is facing a wall, {\tt False} otherwise)
\item home ({\tt True} if the robot is home, {\tt False} otherwise)
\item gem ({\tt True} if the robot stands on a gem, {\tt False} otherwise)
\item north ({\tt True} if the robot is facing North, {\tt False} otherwise)
\item empty ({\tt True} if the robot does not have any gems on him, {\tt False} otherwise)
\end{itemize}

\subsection{Logical variables}

In programming as well as in real life we often deal with logical expressions that are 
fairly complex. Often we use two or more simple logical expressions in one sentence, 
and moreover combine them with logical operations {\em and}, {\em or} or {\em not}.

For example, the sentence "I will go skiing on Saturday if weather is good and if 
Michael goes as well." includes three simple logical expressions. Let's call 
them for brevity\\

\noindent
A = "I will go skiing on Saturday."\\
B = "The weather is good."\\
C = "Michael goes as well."\\

\noindent
There is a logical operation {\em and} between the expressions B and C.

The original sentence can be written briefly as "if (B and C) then A". We love this kind of 
brevity in programming! A, B and C are {\em logical variables}. Logical variables 
can only represent {\tt True} or {\tt False}, and their purpose is to ease the operation with 
longer expressions.
Regarding the original sentence, we could go one step further and define a new logical variable\\

\noindent
D = B {\em and} C.\\

\noindent
Then, the sentence would become just "if D then A"! 

\subsection{Logical operations}

It is worth mentioning the following properties of the logical operation {\em and}:\\

\begin{center}
\framebox{(A {\em and} B) is {\tt True} only if both A and B are {\tt True}. Otherwise A {\em and} B is {\tt False}.}
\end{center}
\vspace{4mm}
\noindent
The logical operation {\em or} has the following properties:\\

\begin{center}
\framebox{(A {\em or} B) is {\tt True} if at least one of A, B is {\tt True}. If both A. B are {\tt False}, (A {\em or} B) is {\tt False}.}
\end{center}
\vspace{4mm}
\noindent
We also use the logical operation {\em not} with the following property:\\

\begin{center}
\framebox{({\em not} A) is {\tt True} if A is {\tt False} and vice versa.}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Appendix - Overview of Functionality by Level}\label{sec:newfunc3}

\subsection{Level 0 (Section \ref{sec:manual})}

In Level 0, Karel can be guided by clicking on buttons:
\begin{itemize}
\item Go ... make one step forward.
\item Left ... turn left.
\item Right ... turn right.
\item Put ... put a gem on the ground.
\item Get ... pick up a gem from the ground.
\end{itemize}

\subsection{Level 1 (Section \ref{sec:bridge})}

In Level 1, Karel can be guided by typing the commands:
\begin{itemize}
\item {\tt go} ... make one step forward.
\item {\tt left} ... turn left.
\item {\tt right} ... turn right.
\item {\tt put} ... put a gem on the ground.
\item {\tt get} ... pick up a gem from the ground.
\end{itemize}

\subsection{Level 2 (Sections \ref{sec:interm1} -- \ref{sec:recursion})}

New commands:
\begin{itemize}
\item {\tt if - else} ... condition.
\item {\tt repeat} ... counting loop (repeat an action a given number of times).
\item {\tt while} ... conditional loop (repeat an action while a condition is satisfied).
\item {\tt def} ... define a new command.
\end{itemize}
Additional new keywords:
\begin{itemize}
\item {\tt wall} ... sensor that checks True if the robot faces a wall.
\item {\tt gem} ... sensor that checks True if there is a gem within the robot's reach.
\item {\tt empty} ... sensor that checks True if the robot's bag with gems is empty.
\item {\tt home} ... sensor that checks True if the robot is at home.
\item {\tt north} ... sensor that checks True if the robot faces North.
\end{itemize}
New functionality:
\begin{itemize}
\item Recursion (a command can make a call to itself).
\end{itemize}

\subsection{Level 3 (Sections \ref{sec:var}, \ref{sec:logic})}

New keywords:
\begin{itemize}
\item {\tt print} ... print strings and variables.
\item {\tt gpsx} ... GPS coordinate in the horizontal direction.
\item {\tt gpsy} ... GPS coordinate in the vertical direction.
\item {\tt a = 0} ... create a new variable {\tt a} and initialize it with zero (or another 
      integer number).\\ For additional ways to initialize variables see Subsection \ref{par:var}.
\item {\tt inc(a)} ... increases the value of variable {\tt a} by one.
\item {\tt inc(a, value)} ... increases the value of variable {\tt a} by {\tt value}.
\item {\tt dec(a)} ... decreases the value of variable {\tt a} by one.
\item {\tt dec(a, value)} ... decreases the value of variable {\tt a} by {\tt value}.
\item {\tt rand} ... random command (returns randomly True or False).
\item {\tt return} ... returns a value, to be used in functions.
\item {\tt and} ... binary logical {\em and}.
\item {\tt or} ... binary logical {\em or}.
\item {\tt not} ... unary logical {\em not}.
\end{itemize}
New functionality:
\begin{itemize}
\item Numerical and logical (Boolean) variables.
\item Complex logical expressions.
\item Functions can return values.
\end{itemize}
